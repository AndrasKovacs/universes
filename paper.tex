
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles.
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Generalized Universe Hierarchies and First-Class Universe Levels}
%% \titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{András Kovács}{Eötvös Loránd University, Hungary}{kovacsandras@inf.elte.hu}{https://orcid.org/0000-0002-6375-9781}{}

%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional
\authorrunning{A., Kovács} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases):

\Copyright{András Kovács} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/


\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10011740</concept_id>
<concept_desc>Theory of computation~Type theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}

\keywords{type theory, universes} %TODO mandatory; please add comma-separated list of keywords

%% \category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

\funding{The author was supported by the European Union,
co-financed by the European Social Fund (EFOP-3.6.3-VEKOP-16-2017-00002).}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.


%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}


%% --------------------------------------------------------------------------------


\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{scalerel}
\usepackage{amssymb}


%% \theoremstyle{definition}
%% \newtheorem{definition}{Definition}
%% \newtheorem{example}{Example}

%% \theoremstyle{theorem}
%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}{Lemma}

\theoremstyle{remark}
\newtheorem{notation}{Notation}

\theoremstyle{definition}
\newtheorem{mydefinition}{Definition}
\newtheorem{myexample}{Example}
\newtheorem{mylemma}{Lemma}


%% Abbrevs
%% --------------------------------------------------------------------------------

\newcommand{\Set}[1]{\mathsf{Set_{#1}}}
\newcommand{\Seti}{\mathsf{Set}}
\newcommand{\refl}{\mathsf{refl}}
\newcommand{\Con}{\mathsf{Con}}
\newcommand{\Ty}{\mathsf{Ty}}
\newcommand{\Tm}{\mathsf{Tm}}
\newcommand{\Sub}{\mathsf{Sub}}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\U}{\mathsf{U}}
\newcommand{\El}{\mathsf{El}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\ext}{\triangleright}
\newcommand{\blank}{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}
\newcommand{\mi}[1]{\mathit{#1}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\Id}{\mathsf{Id}}
\newcommand{\Nat}{\mathsf{Nat}}
\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\up}{\uparrow}
\newcommand{\down}{\downarrow}
\newcommand{\Lift}{\mathsf{Lift}}
\renewcommand{\tt}{\mathsf{tt}}
\newcommand{\Acc}{\mathsf{Acc}}
\newcommand{\acc}{\mathsf{acc}}
\newcommand{\Lvl}{\mathsf{Lvl}}
\renewcommand{\U}{\mathsf{U}}
\newcommand{\Code}{\mathsf{Code}}


%% --------------------------------------------------------------------------------
\begin{document}
\maketitle

\begin{abstract}
In type theories, universe hierarchies are commonly used to increase the
expressive power of the theory while avoiding inconsistencies arising from size
issues. There are numerous ways to specify universe hierarchies, and theories
may differ in details of cumulativity, choice of universe levels, specification
of type formers and eliminators, and available internal operations on levels. In
the current work, we aim to provide a framework which covers a large part of the
design space. First, we develop syntax and semantics for cumulative universe
hierarchies, where levels may come from any set equipped with a transitive
well-founded ordering. In the semantics, we show that induction-recursion can be
used to model transfinite hierarchies, and also support lifting operations on
type codes which strictly preserve type formers. Then, we consider a setup where
universe levels are first-class types and subject to arbitrary internal
reasoning. This generalizes the bounded universe polymorphism features of Coq
and also the internal level computations in Agda.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Users of type theories often view universe levels as an unwieldy bureaucratic
detail, a necessary annoyance in service of boosting expressive power while
retaining logical consistency. However, universe hierarchies are not going away
any time soon in practical implementations of type theory. In recent
developments of systems, we are getting more universes and more adjacent
features:

\begin{itemize}
\item Agda recently added a limited version cumulativity as an optional feature
  for universes \cite{agdadocs}, and the upcoming 2.6.2 version will extend the $\omega+1$
  universe hierarchy to $\omega*2$.
\item Coq added support for cumulative inductive types \cite{timany18cumulative}, and added a form of
  bounded universe polymorphism \cite{ziliani15unification}.
\end{itemize}

\noindent At this point, there is a veritable zoo of universe features in existing
implementations. We have perhaps even more design choices when considering the
formal metatheory of type theories. Do type formers stay in the same
universe, or take the $\sqcup$ of universes of constituent types? Can
eliminators target any universe, or do we instead use lifting operators to cross
levels? What kind of universe polymorphism do we have, can we quantify over
bounds? Is there a type of levels, or are levels in a separate syntactic layer?

The aim of the current work is to develop semantics which covers as much as
possible from the range of sensible universe features. This way, theorists and
language implementors can grab a desired bag of features, and be able to show
consistency of their system by a straightforward translation to one of the
systems in this paper.

\paragraph*{Contributions}

\begin{enumerate}
\item In Section \ref{sec:ttgu} we describe models of type theories where
  universe levels may come from any set with a well-founded transitive ordering
  relation. We specify models as categories equipped with level-indexed diagrams
  of families, as a variation on categories with families. Each morphism of
  levels is mapped to a lifting operation on terms and types. By varying the
  preservation properties of lifting operations, we can describe a range of
  stratification features, from two-level type theory to cumulative universes.
\item We use induction-recursion to model the mentioned theories. We model
  the strongest formulations for lifting and universes, namely cumulative
  universes with Russell-style type decoding. The main challenge is combining
  transfinite hierarchies with strictly type-preserving lifting operations.
\item In Section \ref{sec:ttfl} we describe type theories with internal types
  for levels and level morphisms, and extend the previous inductive-recursive
  semantics to cover these as well. Here, we can additionally represent various
  universe polymorphism features and level computations. We illustrate how
  predicative universe features in Coq and Agda could be justified in our framework.
\end{enumerate}

\noindent Several related topics are not handled in this paper.

\begin{itemize}

\item
Besides consistency, we are often interested in \emph{canonicity},
\emph{normalization} or other metatheoretical properties. The current work
focuses on consistency and leaves other properties to future work. However, we
do keep canonicity in mind while specifying our systems, and aim to avoid
pitfalls which would cause canonicity to fail.
\item
We only focus on using universes as sized-based classifiers for
types. Universe-like stratification is also present in two-level type theory
\cite{twolevel}, modal type theories \cite{gratzer20multimodal} or as h-levels
in homotopy type theory \cite{hottbook}, but we do not attempt to cover such use
cases.
\item
We only cover predicative hierarchies.
\end{itemize}

We provide an Agda formalization of the contents of the paper. The formalization
is not complete, as we skip proofs involving an excessive number of equality
coercions (which are more suited to informal reasoning, using equality
reflection), and instead focus on the key points.

\section{Metatheory}
\label{sec:metatheory}

We work in a Martin-Löf type theory which has the following features.
\begin{itemize}
  \item Two universes named $\Set0$ and $\Set1$, where $\Set0$ supports
    inductive-recursive types (IR) as specified by Dybjer and Setzer
    \cite{dybjer99finite}. The $\Set1$ universe is not essential and we only use
    it as a convenience feature, in this paper and in the Agda formalization. We
    may omit the universe indices if they can be inferred or if we work over
    arbitrary indices.
  \item Function extensionality and uniqueness of identity proofs
    (UIP). Additionally, we assume equality reflection in this paper, thus
    working in extensional type theory, to avoid noise from equality transports.
  \item We write function types as $(x : A)\to B$ with $\lambda\,x.\,t$
    inhabitants, and $\Sigma$-types as $(x : A) \times B$, with pairing as
    $(t,\, u)$ and projections as $t.1$ and $t.2$. We have $\top$ as the unit
    type with inhabitant $\tt$, and $\bot$ as the empty type. Propositional identity
    is written as $t = u$ with $\refl : t = t$.
  \item We occasionally use $\{x : A\} \to B$ for an Agda-like notation for
    function types with implicit arguments, and omit implicit applications
    whenever they can be inferred. We may omit implicit function types
    altogether if it is clear where certain variables are quantified.
\end{itemize}

\section{Type Theories with Generalized Universe Hierarchies}
\label{sec:ttgu}

In this section, we first describe notions of models for type theories with
generalized universes, and discuss several variations of universes and lifting
operations. Then, we pick a concrete variant (the strongest, in a sense)
and construct a model for it in the metatheory.

For the basic structure of typing contexts and substitutions, let us review
categories with families.

\subsection{Categories with Families}
\label{sec:categories_with_families}

\begin{mydefinition}
A \emph{category with family} (cwf) \cite{Dybjer96internaltype} consists of the following data:
\begin{itemize}
\item A category with a terminal object. We denote the set of objects as $\Con :
  \Seti$ and use capital Greek letters starting from $\Gamma$ to refer to
  objects. The set of morphisms is $\Sub : \Con \to \Con \to \Seti$, and we use
  $\sigma$, $\delta$ and so on to refer to morphisms. The terminal object is
  $\emptycon$ with unique morphism $\epsilon : \Sub\,\Gamma\,\emptycon$. In
  initial models (that is, syntaxes) of type theories, objects correspond to
  typing contexts, morphisms to parallel substitutions and the terminal object to
  the empty context; this informs the naming scheme that we use here.
\item A \emph{family structure}, containing $\Ty : \Con \to \Seti$ and $\Tm :
  (\Gamma : \Con) \to \Ty\,\Gamma \to \Seti$, where $\Ty$ is a presheaf over the
  category of contexts and $\Tm$ is a presheaf over the category of elements of
  $\Ty$. This means that both types ($\Ty$) and terms ($\Tm$) can be
  substituted, and substitution has functorial action. We use $A$, $B$, $C$ to
  refer to types and $t$, $u$, $v$ to refer to terms, and use $A[\sigma]$ and
  $t[\sigma]$ for substituting types and terms. Additionally, a family structure
  has \emph{context comprehension} which consists of an context extension
  operation $\blank\ext\blank : (\Gamma : \Con) \to \Ty\,\Gamma \to \Con$
  together with an isomorphism $\Sub\,\Gamma\,(\Delta\ext A) \simeq ((\sigma :
  \Sub\,\Gamma\,\Delta) \times \Tm\,\Gamma\,(A[\sigma]))$ which is natural in
  $\Gamma$.
\end{itemize}
\end{mydefinition}

\noindent From the comprehension structure, we recover the following notions:

\begin{itemize}
\item By going right-to-left along the isomorphism, we recover \emph{substitution extension}
      $\blank,\blank : (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,(A[\sigma])$. This means
      that starting from $\epsilon$ or the identity substitution $\id$, we can iterate $\blank,\blank$
      to build substitutions as lists of terms.
\item By going left-to-right, and starting from $\id : \Sub\,(\Gamma\ext A)\,(\Gamma\ext A)$, we recover
      the \emph{weakening substitution} $\p : \Sub\,(\Gamma\ext A)\,\Gamma$ and the \emph{zero variable}
      $\q : \Tm\,(\Gamma\ext A)\,(A[\p])$.
\item By weakening $\q$, we recover a notion of variables as De Bruijn indices. In general, the $n$-th
      De Bruijn index is defined as $\q[\p^{n}]$, where $\p^{n}$ denotes $n$-fold composition.
\end{itemize}

There are other ways for presenting the basic categorical structure of models,
which are nonetheless equivalent to cwfs, including natural models \cite{awodey18natural}
and categories with attributes \cite{cartmellthesis}. We use the cwf presentation for its
immediately algebraic character and closeness to syntax, as an explicit
substitution calculus can be directly read off the specification.

\begin{notation}As De Bruijn indices are hard to read, we will mostly use
nameful notation for binders. For example, assuming $\Nat : \{\Gamma : \Con\}
\to \Ty\,\Gamma$ and $\Id : \{\Gamma : \Con\}(A : \Ty\,\Gamma) \to
\Tm\,\Gamma\,A \to \Tm\,\Gamma\,A \to \Ty\,\Gamma$, we may write $\emptycon \ext
(n : \Nat) \ext (p : \Id\,\Nat\,n\,n)$ for a typing context, instead of using
numbered variables or cwf combinators as in $\emptycon \ext \Nat \ext
\Id\,\Nat\,\q\,\q$.
\end{notation}

\begin{notation}
In the following, we will denote families by ($\Ty$,$\Tm$) pairs and overload context
extension $\blank\ext\blank$ for different families.
\end{notation}

A family structure may be closed under certain \emph{type formers}. For example,
we may close a family over function types by assuming $\Pi : (A : \Ty\,\Gamma)
\to \Ty\,(\Gamma\ext A) \to \Ty\,\Gamma$ together with abstraction, application,
$\beta\eta$-rules, and equations for the action of substitution on type and term
formers.

In the following, whenever we introduce a type former, we always assume that it
is natural with respect to substitution, i.e.\ all type and term formers have a
corresponding substitution rule.

\subsection{Morphisms, Liftings and Inclusions of Families}
\label{sec:morphisms}

In the rest of the paper we make use of categories equipped with possibly
multiple family structures, which serves as basis for specifying universe
hierarchies. However, it is not very useful to simply have multiple copies of
family structures together with their type formers. In that case, every
constructor and eliminator of every type former stays in the same family, and
there is no interaction between families, and the most we can do is to mix them
together in typing contexts. In this subsection we describe several ways of
crossing between families.

\begin{mydefinition}
A \emph{family morphism} $F$ between ($\Tm_0$, $\Ty_0$) and ($\Tm_1$, $\Ty_1$)
families consists of natural transformations mapping types to types and terms to
terms, which preserves context extensions up to context isomorphism, i.e.\ we
have that $(\Gamma \ext F\,A) \simeq (\Gamma \ext A)$, where $\simeq$ denotes
existence of an invertible context morphism.
\end{mydefinition}

Family morphisms are restrictions of so-called \emph{weak morphisms}
\cite{dependentrightadjoints} (or \emph{pseudomorphisms}
\cite{kaposi2019gluing}) of cwfs: a weak morphism which has the identity action
on the base category is exactly a family morphism. A plain family morphism is
still not too interesting, so we add more features.

\begin{mydefinition}
A \emph{lifting} is a family morphism which is bijective on terms. Note that
we can drop the $\ext$-preservation condition from the specification of
liftings, since it follows from the invertible action on terms.
\end{mydefinition}

\begin{notation}
We write $\Lift : \Ty_0\,\Gamma \to \Ty_1\,\Gamma$ for the action of some lifting
on types, $\up : \Tm_0\,\Gamma\,A \to \Tm_1\,\Gamma\,(\Lift\,A)$ for the action
on terms, and $\down$ for the inverse action on terms.
\end{notation}

\todo{Mention dependent right adjoints}

\paragraph{Two-level type theory}
Assume family structures ($\Ty_0$, $\Tm_0$) and ($\Ty_1$, $\Tm_1$) and a
lifting between them. This corresponds to a basic version of \emph{two-level
  type theory} \cite{twolevel}. This theory can be interpreted as having ($\Ty_1$,
$\Tm_1$) as a metaprogramming layer which can generate object-level programs in
the ($\Ty_0$, $\Tm_0$) layer.

Lifted types correspond to types of object-level expressions; for
example, $\Bool_0 : \Ty_0\,\Gamma$ is the object-level type of Booleans, while
$\Lift\,\Bool_0$ is the meta-level type of $\Bool_0$-expressions, and $\Bool_1 :
\Ty_1\,\Gamma$ is the type of meta-level Booleans. It is possible to compute a
$\Lift\,\Bool_0$ from a $\Bool_1$. Given $b : \Tm_1\,\Gamma\,\Bool_1$, we can
construct
$\down(\mathsf{if}\,b\,\mathsf{then}\up\!\true_0\,\mathsf{else}\up\!\false_0) :
\Tm_0\,\Gamma\,\Bool_0$.

But there is no way to compute a $\Bool_1$ from a $\Lift\,\Bool_0$, since
$\Lift\,\Bool_0$ has no elimination rule in $\Ty_1$. Conceptually, terms
of $\Lift\,\Bool_0$ are \emph{expressions}, so they are not necessarily $\true$ or
$\false$, they can also be variables or neutral expressions, so the usual
Boolean elimination is not justified for them. In general, the setup ensures that
we can eliminate from positive types in $\Ty_1$ to their counterparts in
$\Ty_0$, but not the other way around, while negative types are preserved by
$\Lift$ up to type isomorphism.

Remarkably, the simple rules of two-level type theory appear to model a form of
generative two-stage compilation with dependent types. Comparing this system to
e.g.\ BER MetaOCaml \cite{kiselyov14metaocaml}, we can relate $\Lift$ to $\mathsf{code}$, $\up$
to the quasi-quotation operation $<\!\blank\!>$, and $\down$ to escape
$\sim\!\blank$.

While the staging aspect could be subject of future research, we currently focus
on ``sizing'' hierarchies instead of staging hierarchies. This means that we
want to eliminate from any family to any other family which is ``connected'' by
a morphism.

\begin{mydefinition}\label{def:inclusion}
A \emph{family inclusion} is a lifting which preserves all type and term
formers. This assumes that every type former which is contained in the source
family, is also contained in the target family.
\end{mydefinition}

\noindent Some examples for preservation equations for type and term formers:
\begin{alignat*}{3}
  & \Lift\,(\Pi\,(x : A) B)   && =\,\,\,\,&& \Pi\,(x : \Lift\,A)(\Lift\, (B[x \mapsto\,\down\!x]))\\
  & \up(\lambda\,(x : A).\,t) && =&& \lambda\,(x : \Lift\,A).\up(t[x\mapsto\down\!x])\\
  & \Lift\,\Bool_0            && =&& \Bool_1\\
  & \up\true_0                && =&& \true_1
\end{alignat*}
In general, we can skip specifying preservation for $\down$, since it follows from $\up$ preservation
equations.

Assume an inclusion from ($\Ty_0$, $\Tm_0$) to ($\Ty_1$, $\Tm_0$). Now, we can
eliminate from $\Bool_0$ to $\Bool_1$. If we have some $b :
\Tm_0\,\Gamma\,\Bool_0$, we also have $\up\!b :
\Tm_1\,\Gamma\,(\Lift_1\,\Bool_0)$, hence $\up\!b :
\Tm_1\,\Gamma\,\Bool_1$. Then, we can use $\Bool_1$ elimination, as in
$\mathsf{if}\,\up\!b\,\,\mathsf{then}\,\true_1\,\mathsf{else}\,\false_1 :
\Tm_1\,\Gamma\,\Bool_1$. The $\up$ computation ensures that the eliminator
computes appropriately on canonical terms: if $b$ is $\true_0$, then we get
$\up\!\true_0 = \true_1$ as the if-then-else scrutinee.

A family inclusion corresponds to a \emph{cumulative hierarchy} consisting of
two families: every type former of the smaller family is included in the larger
family, with the same elimination rules.

\begin{mydefinition}\label{def:strict_inclusion}
A \emph{strict family inclusion} between ($\Tm_0$, $\Ty_0$) and ($\Tm_1$,
$\Ty_1$) is a family inclusion ($\Lift$, $\up$, $\down$) for which the following equations hold:
\begin{alignat}{2}
  & (\Gamma \ext \Lift\,A) &&= (\Gamma \ext A)     \label{eq:cumcon}    \\
  & \Tm_1\,\Gamma\,(\Lift\,A) &&= \Tm_0\,\Gamma\,A  \label{eq:cumtm}     \\
  & \up\!t &&= t                                    \label{eq:cumlift}
\end{alignat}
\end{mydefinition}

A strict inclusion corresponds to Sterling's \emph{algebraic cumulativity}
\cite{sterling2019algebraic}. The additional equations are a matter of convenience: they allow us
to omit term liftings in informal syntax\footnote{In a proof assistant, we would
  still have to explicitly transport along the strict inclusion
  equations.}. Most of the time we can also omit level annotations
on term formers. For example, we have $\true_0 : \Tm_0\,\Gamma\,\Bool_0$,
but also $\true_0 : \Tm_0\,\Gamma\,(\Lift\,\Bool_0)$, hence $\true_0 :
\Tm_0\,\Gamma\,\Bool_1$. Moreover, $\true_0$ is definitionally equal to
$\true_1$, since $\true_0 =\,\up\!\true_0 = \true_1$. Thus, using simply $\true$
is fine whenever the family is clear from context.

The definitional equality of $\true_0$ and $\true_1$ is important; without it
canonicity would fail, since $\true_0$, $\false_0$, $\true_1$ and $\false_1$
would be four definitionally distinct inhabitants of $\Bool_1$. See Luo
\cite{luo2012notes} for a discussion of related issues with cumulativity. It is
not sufficient to specify a strict inclusion just by equations \ref{eq:cumcon}
and \ref{eq:cumtm} in Definition \ref{def:strict_inclusion}, we need $\up$
together with equation \ref{eq:cumlift} to identify term formers in different
families. The other direction $\down\!t = t$ is immediately derivable.

\subsection{Level Structures}
\label{sec:level_structures}

We would like to describe a range of setups with multiple families and morphisms
between them. In this subsection we describe the indexing structures for such
family diagrams. First, some preliminary definitions.

\begin{mydefinition} The \emph{accessibility predicate} on relations is defined by the following
inductive rules:
\begin{alignat*}{3}
  & \Acc : \{A : \Seti\}(R : A \to A \to \Seti) \to A \to \Seti \\
  & \acc : \{a : A\} \to ((\mi{a'} : A) \to R\,\mi{a'}\,a \to \Acc\,R\,\mi{a'}) \to \Acc\,R\,a
\end{alignat*}
\end{mydefinition}

\noindent An inhabitant of $\Acc\,R\,a$ proves that starting from $a : A$ all
descending $R$-chains must be finite. This is ensured by the universal property
of the inductive definition, as all inductive types must be well-founded.

\begin{mylemma}
Accessibility is a mere proposition, i.e.\ all inhabitants of $\Acc\,R\,a$ are
propositionally equal \cite[Lemma 10.3.4]{hottbook}.
\end{mylemma}

\begin{mydefinition}
A relation $R : A \to A \to \Seti$ is \emph{well-founded} if $(a : A) \to
\Acc\,R\,a$.
\end{mydefinition}

\begin{mylemma}
Every well-founded relation is irreflexive \cite[Lemma 10.4.2]{hottbook}.
\end{mylemma}

\begin{mydefinition} A \emph{level structure} consists of the following components:
\begin{alignat*}{3}
  & \Lvl                  &&: \Set0 \\
  & \blank\!<\!\blank     &&: \Lvl \to \Lvl \to \Set0 \\
  & \mathsf{<\!prop }     &&: (p\,q : i < j) \to p = q \\
  & \blank\!\circ\!\blank &&: j < k \to i < j \to i < k \\
  & \mathsf{<\!wf}        &&: (i : \Lvl) \to \Acc\,<\,i
\end{alignat*}
\end{mydefinition}

\noindent We overload $\Lvl$ to refer to a given level structure and also its
underlying set. In short, a level structure is a set together with a transitive
well-founded relation.

\begin{mydefinition}
A \emph{family diagram} over $\Lvl$ maps each $i : \Lvl$ to a family structure
($\Ty_i$, $\Tm_i$), and each $p : i < j$ to a family inclusion
($\Lift_{i}^{j}\,p$, $\up_{i}^{j}p$, $\down_{i}^{j}p$) between ($\Ty_i$,
$\Tm_i$) and ($\Ty_j$, $\Tm_j$). Moreover, the mapping is functorial, so
$\Lift_{i}^{k}\,(p\circ q)\,A = \Lift_{j}^{k}\,p\,(\Lift_{i}^{j}\,q\,A)$, and
similarly for $\up_{i}^{j}p$ and $\down_{i}^{j}p$. A \emph{strict family diagram}
is a family diagram where each inclusion is strict.
\end{mydefinition}

\begin{notation}
Sometimes we omit some of the $i$, $j$, $p$ annotations from type and term
liftings, if they are clear from context.
\end{notation}

Our choice of level structures and diagrams is motivated by the following
reasons. First, we do not need identity morphisms in levels, because they would
be mapped to trivial liftings, which are not interesting in our setting. Second,
we do not need proof-relevant level morphisms, since any parallel pair of family
liftings gives rise to isomorphic types. Concretely, given $p : i < j$ and $q :
i < j$ such that $p \neq q$, we have $\Tm_j\,\Gamma\,(\Lift\,p\,A) \simeq
\Tm_i\,\Gamma\,A \simeq \Tm_j\,\Gamma\,(\Lift\,q\,A)$, and since $\Lift\,p\,A$
and $\Lift\,q\,A$ are in the same family, we can internally prove them
isomorphic using function types and identity types. That said, every construction
in this paper would still work with inverse categories as level structures.

\subsection{Universes}
\label{sec:universes}

At this point, we can talk about family diagrams, but no previously seen type
former depends on levels in an interesting way. For example, $\Bool_i$ has the
same canonical inhabitants as $\Bool_j$, for any $i$ and $j$. Universes
introduce dependency on levels, by serving as classifiers for smaller families internally
to larger families.

\todo{find reference for Coquand univ}

\begin{mydefinition} A family diagram supports \emph{universe formation} if it supports the following:
\begin{alignat*}{3}
  & \U             &&: (i\,j : \Lvl) \to i < j \to \Ty_j\,\Gamma\\
  & \mathsf{LiftU} &&: \Lift_{j}^{k}\,p\,(\U\,i\,j\,q) = \U\,i\,k\,(p \circ q)
\end{alignat*}
\end{mydefinition}
We also need a way to pin down universes as classifiers. We consider two variants.
\begin{mydefinition}
A family diagram has \emph{Coquand universes} if it has universe formation and
additionally supports $\El : \Tm_j\,\Gamma\,(\U\,i\,j\,p) \to \Ty_i\,\Gamma$, and
its inverse $\Code : \Ty_i\,\Gamma \to \Tm_j\,\Gamma\,(\U\,i\,j\,p)$.
\end{mydefinition}
\begin{mydefinition}
A family diagram has \emph{Russell universes} if it has Coquand universes and
additionally satisfies $\Tm_j\,\Gamma\,(\U\,i\,j\,p) = \Ty_i\,\Gamma$ and
$\El\,t = t$.
\end{mydefinition}

The move from Coquand to Russell universes is fairly similar to the move from
inclusions to strict inclusions. The Russell variant makes it possible to
informally omit $\El$ and $\Code$. Likewise, the $\El\,t = t$ condition ensures
appropriate naturality. If we only assumed $\Tm_j\,\Gamma\,(\U\,i\,j\,p) =
\Ty_i\,\Gamma$ but not Coquand universes, we would not be able to prove that a
$t : \Tm_j\,\Gamma\,(\U\,i\,j\,p)$ substituted \emph{as a term} is the same
thing as $t$ substituted \emph{as a type}. Both would be written as $t[\sigma]$
in our notation, but they involve different $\blank[\blank]$ operations.

Unlike every other type or term former, there is no lifting computation rule for
$\El$ and $\Code$. Intuitively, the issue is that we would need to relate type
lifting and term lifting, but while term lifting has invertible action, type
lifting does not. $\Lift$ sends a $\Ty_i\,\Gamma$ to a $\Ty_j\,\Gamma$, and a
larger $\Ty$ is not isomorphic a smaller one, because it contains more
universes. So, for example, lifting $\Bool_0 : \Ty_0\,\Gamma$ as a type to
$\Ty_1\,\Gamma$ yields $\Bool_1$, but lifting $\Bool_0$ as a term yields
$\Bool_0$.

Assuming Coquand or Russell universes and $p : i < j$, we can recover
polymorphic functions, for example, we may have $\mi{id} : \Pi(A : \U\,i\,j\,p)
(\Lift\,p\,(\El\,A) \to \Lift\,p\,(\El\,A))$ for the polymorphic identity. Here,
we quantify over terms of $\U$, and since every type former stays on the same
level (including $\Pi$), we have to $\Lift$ the types in the codomain to the
level of the domain. We can also recover large elimination, for example as in
\[
(\lambda\,(b : \Bool_j).\,\mathsf{if}\,b\,\mathsf{then}\,\Code\,\top_i\,\mathsf{else}\,\Code\,\bot_i)
: \Tm_j\,\Gamma\,(\Bool_j \to \U\,i\,j\,p).
\]

\section{Semantics}
\label{sec:semantics}

In this section we give a model for a type theory with generalized
universes. Let's make the notion of model concrete first.

\begin{mydefinition} Fix a $\Lvl$ structure. A model for a type theory with $\Lvl$-indexed
universes consists of the following:
\begin{enumerate}
  \item A base category ($\Con$, $\Sub$) with a terminal object $\emptycon$.
  \item A strict family diagram ($\Ty_i$, $\Tm_i$) over $\Lvl$, supporting Russell
        universes, and each family structure is closed under the same basic type formers.
\end{enumerate}
\end{mydefinition}

We abbreviate the theory as TTGU, for ``type theory with generalized
universes''. The choice of available basic type formers is up to personal taste,
and it will not significantly affect the following model construction.





\subsection{Inductive-Recursive Codes}
\label{sec:inductive_recursive_codes}

IR codes, code lifting, properties,

\subsection{Model}

List a bunch of things in the model.

\section{Type Theories with First-Class Universe Levels}
\label{sec:ttfl}

Specification of the theory



%% --------------------------------------------------------------------------------


\bibliography{references}
\end{document}
